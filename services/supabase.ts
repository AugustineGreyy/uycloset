

import { createClient } from '@supabase/supabase-js';
import { Database, Json } from '../database.types';
import { ClothingItem, NewsletterSubscription, Category, SiteConfig } from '../types';

// IMPORTANT: Replace with your actual Supabase URL and Anon Key.
// You can get these from your Supabase project settings.
const supabaseUrl = process.env.SUPABASE_URL || 'https://wuowrcujwxfeoqfueyjv.supabase.co';
const supabaseAnonKey = process.env.SUPABASE_ANON_KEY || 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Ind1b3dyY3Vqd3hmZW9xZnVleWp2Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTM3MDAzMDEsImV4cCI6MjA2OTI3NjMwMX0.5rO9fjKll56nbT9VlqiYmjbRZT8a1aoC3s-SpfW-cBo';

// =================================================================================
// DATABASE SETUP GUIDE
// =================================================================================
// This project requires a one-time setup of your Supabase project. The Admin
// Dashboard will guide you if any errors are detected.
//
// ---------------------------------------------------------------------------------
// SECTION 1: TROUBLESHOOTING FOR EXISTING SETUPS
// ---------------------------------------------------------------------------------
// If you see an error, your database schema might be out of date.
// Run the corresponding SQL command below in your Supabase SQL Editor to fix it.
//
// -> Error: "column clothing_items.categories does not exist" or "cannot cast type text to text[]"
//    -- This indicates your schema uses the old single-category system. Run this to migrate:
//    -- Step 1: Alter column to be a text array, preserving existing data.
//    -- ALTER TABLE public.clothing_items ALTER COLUMN category TYPE TEXT[] USING ARRAY[category];
//    -- Step 2: Rename the column to 'categories'.
//    -- ALTER TABLE public.clothing_items RENAME COLUMN category TO categories;
//
// -> Error: "Cannot read properties of undefined (reading '0')" or similar TypeError
//    -- This can happen if some items have a NULL value in the 'categories' column,
//    -- especially after migrating from a single category string to a text array.
//    -- Run this command to find and fix them. It uses the item's name as a fallback.
//    UPDATE public.clothing_items SET categories = ARRAY[name] WHERE categories IS NULL;
//    -- To prevent this in the future, you can also enforce a NOT NULL constraint:
//    ALTER TABLE public.clothing_items ALTER COLUMN categories SET NOT NULL;
//
// -> Error: "column clothing_items.is_review does not exist"
//    ALTER TABLE public.clothing_items ADD COLUMN is_review BOOLEAN DEFAULT false NOT NULL;
//
// -> Error: "relation "public.review_images" does not exist"
//    -- This table is no longer used. If you have it, you can safely delete it:
//    DROP TABLE IF EXISTS public.review_images;
//
// -> Error: "column clothing_items.is_featured does not exist" or similar old errors
//    ALTER TABLE public.clothing_items DROP COLUMN IF EXISTS is_featured;
//    ALTER TABLE public.clothing_items DROP COLUMN IF EXISTS is_for_sale;
//    ALTER TABLE public.clothing_items DROP COLUMN IF EXISTS price;
//
// -> Error: "invalid input syntax for type uuid" (when sharing a wishlist)
//    ALTER TABLE public.wishlists ALTER COLUMN id SET DATA TYPE TEXT;
//
// ---------------------------------------------------------------------------------
// SECTION 2: FULL SETUP FOR NEW PROJECTS
// ---------------------------------------------------------------------------------
// For new setups, run all commands below in your Supabase SQL Editor.
//
// Step 1: Create Tables
//
// CREATE TABLE public.clothing_items (
//   id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
//   created_at TIMESTAMPTZ DEFAULT now() NOT NULL,
//   name TEXT NOT NULL,
//   categories TEXT[] NOT NULL,
//   image_url TEXT NOT NULL,
//   image_path TEXT NOT NULL,
//   product_code TEXT NOT NULL UNIQUE,
//   is_review BOOLEAN DEFAULT false NOT NULL
// );
//
// CREATE TABLE public.categories (
//   id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
//   created_at TIMESTAMPTZ DEFAULT now() NOT NULL,
//   name TEXT NOT NULL UNIQUE
// );
//
// CREATE TABLE public.newsletter_subscriptions (
//   id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
//   email TEXT NOT NULL UNIQUE,
//   created_at TIMESTAMPTZ DEFAULT now() NOT NULL
// );
//
// CREATE TABLE public.wishlists (
//   id TEXT PRIMARY KEY,
//   created_at TIMESTAMPTZ DEFAULT now() NOT NULL,
//   expires_at TIMESTAMPTZ NOT NULL,
//   item_ids JSONB NOT NULL
// );
//
// CREATE TABLE public.site_config (
//   key TEXT PRIMARY KEY,
//   value JSONB NOT NULL,
//   created_at TIMESTAMPTZ DEFAULT now() NOT NULL,
//   updated_at TIMESTAMPTZ DEFAULT now() NOT NULL
// );
//
// Step 2: Create Trigger for 'site_config'
//
// CREATE OR REPLACE FUNCTION public.handle_site_config_update()
// RETURNS TRIGGER AS $$
// BEGIN
//   NEW.updated_at = now();
//   RETURN NEW;
// END;
// $$ LANGUAGE plpgsql;
//
// CREATE TRIGGER on_site_config_update
// BEFORE UPDATE ON public.site_config
// FOR EACH ROW
// EXECUTE FUNCTION public.handle_site_config_update();
//
// Step 3: Enable Row Level Security (RLS) for all tables
// -- Run this for each table you create: clothing_items, categories, etc.
// ALTER TABLE public.table_name ENABLE ROW LEVEL SECURITY;
//
// Step 4: Create Security Policies
//
// -- Public can read from most tables
// CREATE POLICY "Public read access" ON public.clothing_items FOR SELECT USING (true);
// CREATE POLICY "Public read access" ON public.categories FOR SELECT USING (true);
// CREATE POLICY "Public read access" ON public.site_config FOR SELECT USING (true);
//
// -- Admin (authenticated user) gets full control
// CREATE POLICY "Admin full access" ON public.clothing_items FOR ALL TO authenticated WITH CHECK (true);
// CREATE POLICY "Admin full access" ON public.categories FOR ALL TO authenticated WITH CHECK (true);
// CREATE POLICY "Admin full access" ON public.site_config FOR ALL TO authenticated WITH CHECK (true);
//
// -- Special policies for Newsletter
// CREATE POLICY "Public can subscribe" ON public.newsletter_subscriptions FOR INSERT WITH CHECK (true);
// CREATE POLICY "Admin can manage subscribers" ON public.newsletter_subscriptions FOR ALL TO authenticated WITH CHECK (true);
//
// -- Special policies for Wishlists
// CREATE POLICY "Public can read wishlists" ON public.wishlists FOR SELECT USING (true);
// CREATE POLICY "Public can create wishlists" ON public.wishlists FOR INSERT WITH CHECK (true);
//
// Step 5: Create Storage Buckets and Policies
//
// a) In the Supabase Dashboard, go to "Storage" and create ONE PUBLIC bucket:
//    - `clothing-images`
//
// b) Run the following SQL to set security policies for the bucket.
//
// -- Policies for 'clothing-images' bucket
// CREATE POLICY "Public read access for clothing-images"
// ON storage.objects FOR SELECT
// USING ( bucket_id = 'clothing-images' );
//
// CREATE POLICY "Allow authenticated access on clothing-images"
// ON storage.objects FOR ALL TO authenticated
// USING ( bucket_id = 'clothing-images' );
//
// =================================================================================


if (supabaseUrl === 'YOUR_SUPABASE_URL' || supabaseAnonKey === 'YOUR_SUPABASE_ANON_KEY') {
    console.warn("Supabase credentials are not set. Please update services/supabase.ts");
}

export const supabase = createClient<Database>(supabaseUrl, supabaseAnonKey);

const CLOTHING_BUCKET_NAME = 'clothing-images';

// Fetch all clothing items from the database
export const getClothingItems = async (): Promise<ClothingItem[]> => {
    const { data, error } = await supabase
        .from('clothing_items')
        .select('*')
        .order('created_at', { ascending: false });

    if (error) {
        console.error('Error fetching clothing items:', error.message);
        throw error;
    }
    
    return data || [];
};

// Fetch multiple clothing items by their IDs
export const getClothingItemsByIds = async (ids: number[]): Promise<ClothingItem[]> => {
    if (!ids || ids.length === 0) return [];

    const { data, error } = await supabase
        .from('clothing_items')
        .select('*')
        .in('id', ids);

    if (error) {
        console.error('Error fetching items by IDs:', error.message);
        throw error;
    }

    if (!data) return [];
    
    // Preserve the original order of IDs using a Map for better performance
    const dataById = new Map(data.map(item => [item.id, item]));
    const sortedData = ids
        .map(id => dataById.get(id))
        .filter((item): item is ClothingItem => !!item);
    
    return sortedData;
};

// Add a new clothing item
export const addClothingItem = async (
    itemData: {
        categories: string[];
        file: File;
        is_review: boolean;
    }
): Promise<ClothingItem> => {
    const { categories, file, is_review } = itemData;

    if (!categories || categories.length === 0) {
        throw new Error("At least one category must be selected.");
    }

    // 1. Upload image to Supabase Storage first.
    const fileExt = file.name.split('.').pop();
    const fileName = `${Date.now()}.${fileExt}`;
    const filePath = `items/${fileName}`;

    const { error: uploadError } = await supabase.storage
        .from(CLOTHING_BUCKET_NAME)
        .upload(filePath, file);

    if (uploadError) {
        console.error('Error uploading image:', uploadError.message);
        throw uploadError;
    }

    // 2. Get public URL for the uploaded image.
    const { data: { publicUrl } } = supabase.storage
        .from(CLOTHING_BUCKET_NAME)
        .getPublicUrl(filePath);

    if (!publicUrl) {
        // Clean up the orphaned image if we can't get a URL
        await supabase.storage.from(CLOTHING_BUCKET_NAME).remove([filePath]);
        throw new Error('Could not get public URL for the image.');
    }

    // 3. Generate name and insert new record, handling potential product_code collisions.
    let attempts = 0;
    const maxAttempts = 5;
    while (attempts < maxAttempts) {
        const productCode = Math.random().toString(36).substring(2, 7).toUpperCase();
        
        const newItem: Database['public']['Tables']['clothing_items']['Insert'] = {
            name: categories[0],
            categories: categories,
            image_url: publicUrl,
            image_path: filePath,
            product_code: productCode,
            is_review
        };
        
        const { data, error: insertError } = await supabase
            .from('clothing_items')
            .insert([newItem])
            .select()
            .single();

        if (insertError) {
            // Check if the error is a unique constraint violation (Postgres error code 23505) on the product_code
            if (insertError.code === '23505' && insertError.message.includes('product_code')) {
                console.warn(`Product code collision for ${productCode}. Retrying... (${attempts + 1}/${maxAttempts})`);
                attempts++;
                continue; // Retry with a new code
            } else {
                // For any other error, clean up the orphaned image and throw
                console.error('Error inserting new item:', insertError.message);
                await supabase.storage.from(CLOTHING_BUCKET_NAME).remove([filePath]);
                throw insertError;
            }
        }
        
        if (!data) {
            await supabase.storage.from(CLOTHING_BUCKET_NAME).remove([filePath]);
            throw new Error('Item was created but could not be retrieved from the database.');
        }
        return data;
    }
    
    // If we exit the loop, all attempts failed. Clean up and throw.
    await supabase.storage.from(CLOTHING_BUCKET_NAME).remove([filePath]);
    throw new Error(`Failed to generate a unique product code after ${maxAttempts} attempts.`);
};

// Update a specific clothing item
export const updateClothingItem = async (
    id: number,
    updates: Database['public']['Tables']['clothing_items']['Update']
): Promise<void> => {
    const { error } = await supabase
        .from('clothing_items')
        .update(updates) 
        .eq('id', id);
    
    if (error) {
        console.error('Error updating clothing item:', error.message);
        throw error;
    }
};


// Delete a clothing item
export const deleteClothingItem = async (item: ClothingItem): Promise<void> => {
    // Step 1: Delete the associated image from Supabase Storage first to prevent orphaned files.
    if (item.image_path) {
        const { error: storageError } = await supabase.storage
            .from(CLOTHING_BUCKET_NAME)
            .remove([item.image_path]);

        // If an error occurs during file deletion, we stop and report it.
        if (storageError) {
            console.error('Error deleting image from storage:', storageError.message);
            throw new Error(`Failed to delete image file. Check storage policies. Original error: ${storageError.message}`);
        }
    }

    // Step 2: Delete the clothing item record from the database.
    const { error: dbError } = await supabase
        .from('clothing_items')
        .delete()
        .eq('id', item.id);

    // Handle potential database errors.
    if (dbError) {
        console.error('Error deleting item from database:', dbError.message);
        throw new Error(`Failed to delete item record. Check RLS policies. Original error: ${dbError.message}`);
    }
};

// Checks for common database setup issues and returns a user-friendly message.
export const getSetupError = (err: any): string | null => {
    if (!err || !err.message) return null;
    const msg = err.message.toLowerCase();

    // Check for wishlist ID type mismatch
    if (msg.includes('invalid input syntax for type uuid')) {
        return `Database Error: The 'wishlists' table is misconfigured. Please visit the Admin Dashboard for instructions to fix this.`;
    }

    // Check for missing column, a common update issue
    if (msg.includes('column') && msg.includes('does not exist')) {
        const match = msg.match(/column "(.+?)" of relation "(.+?)" does not exist/i) || msg.match(/column "public\.(.+?)"\."(.+?)" does not exist/i);

        if (match && match.length >= 3) {
             const table = match[1].includes('.') ? match[1].split('.')[1] : match[2];
             return `Database Error: The '${table}' table is missing a column. Go to the Admin Dashboard for setup instructions.`;
        }
        return "A database column is missing. The Admin Dashboard has a guide to fix this.";
    }


    const missingTables = [
        'site_config',
        'wishlists',
        'clothing_items',
        'newsletter_subscriptions',
        'categories'
    ];
    for (const table of missingTables) {
         if (msg.includes(`relation "public.${table}" does not exist`)) {
            return `Database Error: The '${table}' table is missing. The Admin Dashboard setup guide will help you create it.`;
        }
    }

    if (msg.includes('violates row-level security policy for table "wishlists"')) {
        return "Wishlist blocked by security. Check 'wishlists' policies on Admin page.";
    }
    if (msg.includes('violates row-level security policy')) {
        return "Action blocked by security rules. Check policies on Admin page.";
    }
    if (msg.includes('permission denied for table')) {
        return "Permission denied for table. Check policies on Admin page.";
    }
    
    return null;
};

// Delete ALL clothing items and their associated images
export const deleteAllClothingItems = async (): Promise<void> => {
    // Step 1: Fetch all item records to get their image paths.
    const { data: items, error: fetchError } = await supabase
        .from('clothing_items')
        .select('image_path');

    if (fetchError) {
        console.error('Error fetching items for deletion:', fetchError.message);
        throw new Error(`Could not fetch items to delete. DB error: ${fetchError.message}`);
    }

    if (!items || items.length === 0) {
        return;
    }
    
    // Step 2: Delete all associated images from Supabase Storage.
    const imagePaths = items.map((item) => item.image_path).filter((path): path is string => !!path);
    
    if (imagePaths.length > 0) {
        const { error: storageError } = await supabase.storage
            .from(CLOTHING_BUCKET_NAME)
            .remove(imagePaths);

        if (storageError) {
            console.error('Error deleting images from storage:', storageError.message);
            throw new Error(`Failed to delete image files from storage. Original error: ${storageError.message}`);
        }
    }

    // Step 3: Delete all records from the clothing_items table.
    const { error: dbError } = await supabase
        .from('clothing_items')
        .delete()
        .neq('id', -1);

    if (dbError) {
        console.error('Error deleting all items from database:', dbError.message);
        throw new Error(`Failed to delete all item records. Original error: ${dbError.message}`);
    }
};

// Delete clothing items by type (either collection items or review items)
export const deleteItemsByType = async (is_review: boolean): Promise<void> => {
    // Step 1: Fetch all item records of the specified type to get their image paths.
    const { data: items, error: fetchError } = await supabase
        .from('clothing_items')
        .select('image_path')
        .eq('is_review', is_review);

    if (fetchError) {
        console.error(`Error fetching items for deletion (is_review: ${is_review}):`, fetchError.message);
        throw new Error(`Could not fetch items to delete. DB error: ${fetchError.message}`);
    }

    if (!items || items.length === 0) {
        return; // Nothing to delete
    }
    
    // Step 2: Delete all associated images from Supabase Storage.
    const imagePaths = items.map((item) => item.image_path).filter((path): path is string => !!path);
    
    if (imagePaths.length > 0) {
        const { error: storageError } = await supabase.storage
            .from(CLOTHING_BUCKET_NAME)
            .remove(imagePaths);

        if (storageError) {
            console.error('Error deleting images from storage:', storageError.message);
            throw new Error(`Failed to delete image files from storage. Original error: ${storageError.message}`);
        }
    }

    // Step 3: Delete the records from the clothing_items table.
    const { error: dbError } = await supabase
        .from('clothing_items')
        .delete()
        .eq('is_review', is_review);

    if (dbError) {
        console.error(`Error deleting items from database (is_review: ${is_review}):`, dbError.message);
        throw new Error(`Failed to delete item records. Original error: ${dbError.message}`);
    }
};

// Get total storage usage from the bucket
export const getStorageUsage = async (): Promise<number> => {
    let totalSize = 0;
    const buckets = [CLOTHING_BUCKET_NAME];
    
    for (const bucketName of buckets) {
        const queue: string[] = ['']; // Start with the root directory

        while (queue.length > 0) {
            const currentPath = queue.shift()!;
            let offset = 0;
            const limit = 1000; // Max limit per request
            let hasMore = true;

            while (hasMore) {
                const { data: files, error } = await supabase.storage
                    .from(bucketName)
                    .list(currentPath, { limit, offset });

                if (error) {
                    console.error(`Error listing files in ${currentPath || 'root'} of ${bucketName}:`, error.message);
                    throw error;
                }

                if (!files || files.length === 0) {
                    hasMore = false;
                    continue;
                }
                
                for (const file of files) {
                    if (file.id === null) { // This indicates a folder in Supabase storage listings
                        const folderPath = currentPath ? `${currentPath}/${file.name}` : file.name;
                        queue.push(folderPath);
                    } else if (file.metadata && typeof file.metadata.size === 'number') { // This is a file
                        totalSize += file.metadata.size;
                    }
                }

                if (files.length < limit) {
                    hasMore = false;
                } else {
                    offset += limit;
                }
            }
        }
    }

    return totalSize;
};

// Get total count of clothing items marked as review
export const getReviewItemCount = async (): Promise<number> => {
    const { count, error } = await supabase
        .from('clothing_items')
        .select('*', { count: 'exact', head: true })
        .eq('is_review', true);

    if (error) {
        console.error('Error counting review items:', error.message);
        throw error;
    }

    return count || 0;
};

// Get the total count of clothing items
export const getClothingItemCount = async (): Promise<number> => {
    const { count, error } = await supabase
        .from('clothing_items')
        .select('*', { count: 'exact', head: true });

    if (error) {
        console.error('Error counting clothing items:', error.message);
        throw error;
    }

    return count || 0;
};


// Create a new wishlist that expires in 30 days
export const createWishlist = async (item_ids: number[]): Promise<string> => {
    const expiresAt = new Date();
    expiresAt.setDate(expiresAt.getDate() + 30);

    let attempts = 0;
    const maxAttempts = 5;

    while (attempts < maxAttempts) {
        // Generate a 5-character alphanumeric ID
        const newId = Math.random().toString(36).substring(2, 7).toUpperCase();

        const { data, error } = await supabase
            .from('wishlists')
            .insert([{
                id: newId,
                item_ids: item_ids as Json,
                expires_at: expiresAt.toISOString(),
            }])
            .select('id')
            .single();

        if (error) {
            // Check for primary key violation (Postgres error code 23505)
            if ((error as any).code === '23505') {
                console.warn(`Wishlist ID collision for ${newId}. Retrying... (${attempts + 1}/${maxAttempts})`);
                attempts++;
                continue; // Retry with a new ID
            } else {
                console.error('Error creating wishlist:', error.message);
                throw error;
            }
        }
        
        const result = data;
        if (!result || !result.id) {
            throw new Error('Failed to create wishlist. This might be a permission issue. Please check the Admin page for setup instructions.');
        }

        return result.id;
    }

    // If we exit the loop, all attempts failed.
    throw new Error(`Failed to generate a unique wishlist ID after ${maxAttempts} attempts.`);
};

// Get a wishlist by its ID, checking for expiration
export const getWishlist = async (id: string): Promise<number[] | null> => {
    const { data, error } = await supabase
        .from('wishlists')
        .select('item_ids, expires_at')
        .eq('id', id)
        .single();

    if (error) {
        if (error.code === 'PGRST116') { // "Not a single row was returned"
            return null;
        }
        console.error('Error fetching wishlist:', error.message);
        throw error;
    }

    if (!data) {
        return null;
    }

    // Check for expiration
    if (new Date(data.expires_at) < new Date()) {
        console.log(`Wishlist ${id} has expired.`);
        return null;
    }
    
    const itemIds = data.item_ids;

    // Safely verify and cast the JSON object to number[]
    if (Array.isArray(itemIds) && itemIds.every(i => typeof i === 'number')) {
        return itemIds as number[];
    }
    
    console.warn(`Wishlist ${id} has malformed item_ids data.`);
    return null;
};


// Fetch all site configuration key-value pairs
export const getSiteConfig = async (): Promise<Record<string, any>> => {
    const { data, error } = await supabase.from('site_config').select('key, value');

    if (error) {
        console.error('Error fetching site config:', error.message);
        throw error;
    }
    
    if (!data) {
        return {};
    }

    const config = data.reduce((acc: any, { key, value }) => {
        acc[key] = value;
        return acc;
    }, {} as Record<string, any>);
    
    return config;
};

// Update site configuration (upsert)
export const updateSiteConfig = async (configs: { key: string; value: Json }[]): Promise<void> => {
    const { error } = await supabase.from('site_config').upsert(configs);

    if (error) {
        console.error('Error updating site config:', error.message);
        throw error;
    }
};

// --- Category Functions ---

// Fetch all categories
export const getCategories = async (): Promise<Category[]> => {
    const { data, error } = await supabase
        .from('categories')
        .select('*')
        .order('name', { ascending: true });
    
    if (error) {
        console.error('Error fetching categories:', error.message);
        throw error;
    }
    return data || [];
};

// Add a new category
export const addCategory = async (name: string): Promise<Category> => {
    const { data, error } = await supabase
        .from('categories')
        .insert([{ name }])
        .select()
        .single();
    
    if (error) {
        if ((error as any).code === '23505') { // Unique constraint violation
            throw new Error(`Category "${name}" already exists.`);
        }
        console.error('Error adding category:', error.message);
        throw error;
    }
    if (!data) throw new Error('Category was created but could not be retrieved.');
    return data;
};

// Delete a category
export const deleteCategory = async (id: number): Promise<void> => {
    const { error } = await supabase
        .from('categories')
        .delete()
        .eq('id', id);
    
    if (error) {
        console.error('Error deleting category:', error.message);
        throw error;
    }
};

// --- Newsletter Functions ---

// Add a new subscriber
export const addNewsletterSubscriber = async (email: string): Promise<void> => {
    if (!email) throw new Error("Email cannot be empty.");

    const { error } = await supabase
        .from('newsletter_subscriptions')
        .insert([{ email }]);

    if (error) {
        if ((error as any).code === '23505') { // Unique violation
            throw new Error("This email is already subscribed.");
        }
        console.error("Error adding subscriber:", error.message);
        throw new Error(getSetupError(error) || "Could not subscribe. Please try again.");
    }
};

// Get total count of subscribers
export const getNewsletterSubscriberCount = async (): Promise<number> => {
    const { count, error } = await supabase
        .from('newsletter_subscriptions')
        .select('*', { count: 'exact', head: true });

    if (error) {
        console.error('Error counting subscribers:', error.message);
        throw error;
    }
    return count || 0;
};

// Fetch all subscribers
export const getNewsletterSubscribers = async (): Promise<NewsletterSubscription[]> => {
    const { data, error } = await supabase
        .from('newsletter_subscriptions')
        .select('*')
        .order('created_at', { ascending: false });
    
    if (error) {
        console.error('Error fetching subscribers:', error.message);
        throw error;
    }
    return data || [];
};

// Delete a subscriber by ID
export const deleteNewsletterSubscriber = async (id: number): Promise<void> => {
    const { error } = await supabase
        .from('newsletter_subscriptions')
        .delete()
        .eq('id', id);

    if (error) {
        console.error('Error deleting subscriber:', error.message);
        throw new Error(getSetupError(error) || "Could not delete subscriber. Please try again.");
    }
};

// Delete all subscribers
export const deleteAllNewsletterSubscribers = async (): Promise<void> => {
    const { data: subscribers, error: fetchError } = await supabase
        .from('newsletter_subscriptions')
        .select('id');
    
    if (fetchError) {
        console.error('Error fetching subscribers for deletion:', fetchError.message);
        throw fetchError;
    }

    if (!subscribers || subscribers.length === 0) {
        return; // Nothing to delete
    }

    const idsToDelete = subscribers.map(sub => sub.id);

    const { error } = await supabase
        .from('newsletter_subscriptions')
        .delete()
        .in('id', idsToDelete);

    if (error) {
        console.error('Error deleting all subscribers:', error.message);
        throw error;
    }
};